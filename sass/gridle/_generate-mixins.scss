// |------------------------------------------------------
// |------------------------------------------------------
// | Generate mixins
// |------------------------------------------------------
// |------------------------------------------------------


//
// Generate a custom class for all the states
//
// @param 	list 	$pattern 		The name pattern of the class
// @param 	list 	$statesNames 		The states names to generate
//
@mixin gridle_generate_custom_class(
    $pattern,
    $statesNames : null
) {
    // manage states to generate :
    $states : ();
    @if $statesNames == null {
        // loop on each states to generate names list :
        @each $stateName, $state in $_gridle_states {
            $states : append($states, $stateName);
        }
    } @else {
        $states : $statesNames;
    }

    // loop on each states :
    @each $stateName in $states
    {
        // manage statename :
        @if type-of($stateName) != string {
            $stateName : map-get($stateName, name);
        }

        // classes :
        $classes : gridle_get_state_var(classes, $stateName);

        // genrate the classname :
        @if $classes
        {
            @include gridle_state($stateName, false) {
                #{_gridle_classname($pattern, $stateName)} {
                    @content;
                }
            }
        }
    }
}


//
// Generate all helpers classes
//
@mixin _gridle_generate_helper_classes (
    $states : null,
    $package : null
) {

    // helpers :
    @if _gridle_need_to_generate(float, $package) {
        #{gridle_selector(float, $states, left)} {
            @include gridle_float(left);
        }
        #{gridle_selector(float, $states, right)} {
            @include gridle_float(right);
        }
    }

    @if _gridle_need_to_generate(clear, $package) {
        #{gridle_selector(clear, $states, ignore-pattern)} {
            @include gridle_clear(both);
        }
        #{gridle_selector(clear, $states, left)} {
            @include gridle_clear(left);
        }
        #{gridle_selector(clear, $states, right)} {
            @include gridle_clear(right);
        }
    }

    @if _gridle_need_to_generate(no-gutter, $package) {
        #{gridle_selector(no-gutter, $states, ignore-pattern)} {
            @include gridle_no_gutter();
        }
        #{gridle_selector(no-gutter, $states, left)} {
            @include gridle_no_gutter(left);
        }
        #{gridle_selector(no-gutter, $states, right)} {
            @include gridle_no_gutter(right);
        }
        #{gridle_selector(no-gutter, $states, top)} {
            @include gridle_no_gutter(top);
        }
        #{gridle_selector(no-gutter, $states, bottom)} {
            @include gridle_no_gutter(bottom);
        }
    }

    @if _gridle_need_to_generate(gutter, $package) {
        #{gridle_selector(gutter, $states, ignore-pattern)} {
            @include gridle_gutter(top right bottom left);
        }
        #{gridle_selector(gutter, $states, left)} {
            @include gridle_gutter(left);
        }
        #{gridle_selector(gutter, $states, right)} {
            @include gridle_gutter(right);
        }
        #{gridle_selector(gutter, $states, top)} {
            @include gridle_gutter(top);
        }
        #{gridle_selector(gutter, $states, bottom)} {
            @include gridle_gutter(bottom);
        }
    }

    @if _gridle_need_to_generate(auto-height, $package) {
        #{gridle_selector(auto-height, $states)} {
            height:inherit;
        }
    }

    @if _gridle_need_to_generate(grid-centered, $package) {
        #{gridle_selector(grid-centered, $states)} {
            @include gridle_grid_centered();
        }
    }

    @if _gridle_need_to_generate(container, $package) {
        #{gridle_selector(container, $states)} {
            @include gridle_container();
        }
    }

    @if _gridle_need_to_generate(row-full, $package) {
        #{gridle_selector(row-full, $states)} {
            @include gridle_row_full();
        }
    }

    @if _gridle_need_to_generate(grid-table, $package) {
        #{gridle_selector(grid-table, $states)} {
            @include gridle_grid_table();
        }
    }

    @if _gridle_need_to_generate(grid-adapt, $package) {
        #{gridle_selector(grid-adapt, $states)} {
            @include gridle_grid_adapt();
        }
    }

    @if _gridle_need_to_generate(grid-grow, $package) {
        #{gridle_selector(grid-grow, $states)} {
            @include gridle_grid_grow();
        }
    }

    @if _gridle_need_to_generate(row-align, $package) {
        #{gridle_selector(row-align, $states, left)} {
            @include gridle_row_align(left);
        }
        #{gridle_selector(row-align, $states, center)} {
            @include gridle_row_align(center);
        }
        #{gridle_selector(row-align, $states, right)} {
            @include gridle_row_align(right);
        }
        #{gridle_selector(row-align, $states, middle)} {
            @include gridle_row_align(middle);
        }
        #{gridle_selector(row-align, $states, top)} {
            @include gridle_row_align(top);
        }
        #{gridle_selector(row-align, $states, bottom)} {
            @include gridle_row_align(bottom);
        }
        @if gridle_is_driver(flex) {
            #{gridle_selector(row-align, $states, around)} {
                @include gridle_row_align(around);
            }
            #{gridle_selector(row-align, $states, between)} {
                @include gridle_row_align(between);
            }
        }
    }

    //
    // Wrapping
    //
    @if _gridle_need_to_generate(nowrap, $package) {
        #{gridle_selector(nowrap, $states)} {
            @include gridle_nowrap();
        }
    }
    @if _gridle_need_to_generate(wrap, $package) {
        #{gridle_selector(wrap, $states)} {
            @include gridle_wrap();
        }
    }

    //
    // Visible, hide, etc...
    //
    @if _gridle_need_to_generate(hide, $package) {
        #{gridle_selector(hide, $states)} {
            @include gridle_hide();
        }
    }

    @if _gridle_need_to_generate(not-visible, $package) {
        #{gridle_selector(not-visible, $states)} {
            @include gridle_not_visible();
        }
    }

    @if _gridle_need_to_generate(show, $package) {
        #{gridle_selector(show, $states)} {
            @include gridle_show();
        }
    }

    @if _gridle_need_to_generate(show-inline, $package) {
        #{gridle_selector(show-inline, $states)} {
            @include gridle_show_inline();
        }
    }

    @if _gridle_need_to_generate(visible, $package) {
        #{gridle_selector(visible, $states)} {
            @include gridle_visible();
        }
    }

    //
    // Clear each class :
    //
    @if _gridle_need_to_generate(clear-each, $package) {
        @each $clearName, $clearMap in $_gridle_clear_classes {
            // get count :
            $clearCount : map-get($clearMap, clearEach);
            // what to clear :
            $clearWhat : map-get($clearMap, clearWhat);
            // generate the class :
            #{gridle_selector(clear-each, $states, $clearCount)} {
                @include gridle_clear_each($clearCount, $clearWhat);
            }
        }
    }

    //
    // debug
    //
    @if _gridle_need_to_generate(row-debug, $package) {
        #{gridle_selector(row-debug, $states)} {
            @include gridle_row_debug();
        }
    }
}


//
// Generate json settings
//
@mixin gridle_generate_json_settings() {

    // settings content :
    $gridle-settings-states : "{";

    // generate all classes for differents media queries :
    $statesCount : length($_gridle_states);
    $i : 0;
    @each $stateName, $state in $_gridle_states {

        $name : $stateName;

        $gridle-settings-states : "#{$gridle-settings-states} \"#{$name}\":{";

        @each $varName, $var in $state {

            $value : null;
            @if $varName == "query" {
                $value : gridle_get_media_query($stateName);
            } @else {
                $value : map-get($state,$varName);
            }

            @if $value == null {
                $gridle-settings-states : "#{$gridle-settings-states} \"#{$varName}\" : null,";
            } @elseif type-of($value) == bool {
                $gridle-settings-states : "#{$gridle-settings-states} \"#{$varName}\" : #{$value},";
            } @elseif type-of($value) == map {
                $gridle-settings-states : "#{$gridle-settings-states} \"#{$varName}\" : {";
                @each $vn, $vv in $value {
                    $gridle-settings-states : "#{$gridle-settings-states} \"#{$vn}\" : \"#{$vv}\","
                }
                $gridle-settings-states : "#{$gridle-settings-states} \"_\" : true";
                $gridle-settings-states : "#{$gridle-settings-states} },";
            } @else {
                $gridle-settings-states : "#{$gridle-settings-states} \"#{$varName}\" : \"#{$value}\",";
            }
        }

        $gridle-settings-states : "#{$gridle-settings-states} \"_\" : true";

        @if $i >= $statesCount - 1 {
            $gridle-settings-states : "#{$gridle-settings-states} }";
        } @else {
            $gridle-settings-states : "#{$gridle-settings-states} },";
        }

        // update i :
        $i : $i + 1;

    }

     // generate settings json :
    $gridle-settings-states : "#{$gridle-settings-states}}";
    $gridle-settings : "{";
    $gridle-settings : "#{$gridle-settings} \"version\" : \"#{$_gridle-version}\"";

    // states :
    $gridle-settings : "#{$gridle-settings}, \"states\" : #{$gridle-settings-states}";

    // settings :
    $gridle-settings : "#{$gridle-settings} }";
    #gridle-settings {
        content : $gridle-settings;
    }
}


//
// Generate classes
//
@mixin gridle_generate_classes(
    $states : all,
    $package : all,
    $scope : null
) {

    // init gridle
    @include gridle_init();

    // check if a scope exist
    @if $scope {
        // wrapp grid into scope
        .#{$scope} {
            @include _gridle_generate_classes($states, $package, true);
        }
    } @else {
        // generate classes
        @include _gridle_generate_classes($states, $package, false);
    }
}
$_gridle_generateOnlyOnce : true; // keep track of generate once classes
@mixin _gridle_generate_classes(
    $states : all,
    $package : all,
    $has-parent : false
) {

    // set that we are in generate phase (that can be used anywhere)
    $_gridle_is_in_generate_phase : true !global;

    // get all the registered states that will be processed after
    // to determine which states to generate
    $generate-states : gridle_get_states_names();

    // if we have provided some states to generate
    @if $states != null and $states != all {
        // check if we have only some - in the states list
        // mean that we want to only remove these specified states
        // from the all states list
        $onlyRemove : true;
        @each $stateName in $states {
            @if str-slice($stateName,1,1) != '-' {
                $onlyRemove : false;
            }
        }
        // if we want to only remove some states
        @if $onlyRemove {
            // loop on all the states to remove
            @each $stateName in $states {
                $sn : str-slice($stateName,2);
                $idx : index($generate-states, $sn);
                @if $idx != null {
                    $generate-states : remove-nth($generate-states,$idx);
                }
            }
        } @else {
            $generate-states : $states;
        }
    }


    // generate these classes only once
    @if $_gridle_generateOnlyOnce
    {

        // update status
        $_gridle_generateOnlyOnce : false;

        // | ------------------------
        // | Windows 8 fix
        // | ------------------------

        // Windows 8 fix for snap mode
        @media screen and (max-width: 400px) {
            @-ms-viewport { width: device-width; }
        }

        // | ------------------------
        // | JSON Settings
        // | ------------------------

        // generate json settings
        @if $gridle-generate-json-settings
        {
            @include gridle_generate_json_settings();
        }

    }

    // loop on each states to generate all the classes
    @each $stateName in $generate-states {
        // get the actual state
        $state : gridle_get_state($stateName);
        $classes : gridle_get_state_var(classes, $state);

        // stop here if no classes wanted
        @if $classes {

            // debug
            // @debug("Generate classes for state #{$stateName}");

            // scope all the classes in a media query
            @include gridle_state($state, false) {
                $all_state_keys : map-keys($_gridle_states);
                $current_index : index($all_state_keys, $stateName);
                $upper_states : ();

                $i : 1;
                @while $current_index >= $i {
                    $upper_states : append($upper_states, nth($all_state_keys, $i));
                    $i : $i + 1;
                }

                @if(map-get($state, _context_changed) or map-get($state, _gutter_changed) or map-get($state, _direction_changed)){
                    // generate all classes for columns
                    $i : 0;
                    @each $columnName, $column in gridle_get_columns($state) {

                        // variables
                        $columnsCount : map-get($column, columns);
                        $columnsContext : map-get($column, context);
                        $columnsNameMultiplicator : map-get($column, name-multiplicator);

                        // extend context in state (for columns)
                        $extendedState : map-merge($state, (
                            context : $columnsContext,
                            name-multiplicator : $columnsNameMultiplicator // inject the name multiplicator here getted from column to handle custom registered columns
                        ));

                        // classes
                        @if _gridle_need_to_generate(grid, $package) {
                            #{gridle_selector(grid, $upper_states, $columnName)} {
                                @include gridle_grid($columnsCount, $columnsContext);
                            }
                        }

                        @if(map-get($state, _context_changed) or map-get($state, _direction_changed)){
                            @if _gridle_need_to_generate(push, $package) {
                                #{gridle_selector(push, $upper_states, $columnName)} {
                                    @include gridle_push($columnsCount, $columnsContext);
                                }
                            }
                            @if _gridle_need_to_generate(pull, $package) {
                                #{gridle_selector(pull, $upper_states, $columnName)} {
                                    @include gridle_pull($columnsCount, $columnsContext);
                                }
                            }
                            @if _gridle_need_to_generate(prefix, $package) {
                                #{gridle_selector(prefix, $upper_states, $columnName)} {
                                    @include gridle_prefix($columnsCount, $columnsContext);
                                }
                            }
                            @if _gridle_need_to_generate(suffix, $package) {
                                #{gridle_selector(suffix, $upper_states, $columnName)} {
                                    @include gridle_suffix($columnsCount, $columnsContext);
                                }
                            }
                            @if _gridle_need_to_generate(order, $package) {
                                #{gridle_selector(order, $upper_states, first)} {
                                    @include gridle_order(-1);
                                }
                                #{gridle_selector(order, $upper_states, $i)} {
                                    @include gridle_order($i);
                                }
                                #{gridle_selector(order, $upper_states, last)} {
                                    @include gridle_order(9999);
                                }
                            }
                        }
                        // up $i
                        $i : $i + 1;
                    }
                }

                // row and col classes if the gutter has changed
                @if map-get($state, _gutter_changed){
                    @if _gridle_need_to_generate(row, $package) {
                        #{gridle_selector(row, $upper_states, ignore-pattern)} {
                            @include gridle_row(false);
                        }
                        #{gridle_selector(row, $upper_states, reverse)} {
                            @include gridle_row(true);
                        }
                    }

                    @if _gridle_need_to_generate(col, $package) {
                        #{gridle_selector(col, $upper_states, ignore-pattern)} {
                            @include gridle_col(false);
                        }
                        #{gridle_selector(col, $upper_states, reverse)} {
                            @include gridle_col(true);
                        }
                    }
                }

                // media queries helpers classes
                @include _gridle_generate_helper_classes($upper_states, $package);

                // handle direction on body
                body {
                    direction: gridle_get_state_var(direction);
                }
            }
        }
    }

    // apply css for states of each elements
    @each $map in $_gridle_apply_css_for {
        @each $stateName, $fors in $map {
            @include _gridle_state($stateName, false) {
                @each $f, $rules in $fors {
                    @if map-get($fors, $f) {
                        @if _gridle_need_to_generate($f, $package) {
                            @include gridle_selector($f, null) {
                                @include _gridle_map_2_css($rules);
                            }
                        }
                    }
                }
            }
        }
    }

    // make nested grids working automatically
    // @if _gridle_need_to_generate(col, $package) or _gridle_need_to_generate(row, $package) {
    //     @each $stateName, $state in gridle_get_states() {
    //         $classes : gridle_get_state_var(classes, $state);
    //         @if $classes and gridle_get_state_var(generate-grid, $state) {
    //             $gutter-left : gridle_get_state_var(gutter-left, $state);
    //             $gutter-right : gridle_get_state_var(gutter-right, $state);
    //             @include _gridle_state($stateName, false) {
    //                 $rowSelector : str-slice(_gridle_classname(row),2);
    //                 $colSelector : str-slice(_gridle_classname(col),2);
    //
    //                 //Listing of all posible row
    //                 .#{$rowSelector},
    //                 [class*=" #{$rowSelector}@"], [class*=" #{$rowSelector}-"],
    //                 [class^="#{$rowSelector}@"], [class^="#{$rowSelector}-"],
    //                 //Listing of all posible col
    //                 .#{$colSelector},
    //                 [class*=" #{$colSelector}@"], [class*=" #{$colSelector}-"],
    //                 [class^="#{$colSelector}@"], [class^="#{$colSelector}-"]
    //                 {
    //                     margin-left: -#{$gutter-left};
    //                     margin-right: -#{$gutter-right};
    //                 }
    //             }
    //         }
    //     }
    // }

    // reset the variable that track if we are in generate phase or not
    $_gridle_is_in_generate_phase : false !global;
}
